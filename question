#!/usr/bin/env bash

function usage() {
  cat <<EOF
USAGE:
  $(basename $0) [OPTIONS] <question>

OPTIONS:
  --accepted-inputs=/regex/ Regex string describing what is acceptable.
  --no-colour               Don't colour the string.
  --no-notify               Do not attempt to notify with terminal-notifier.
  --no-revalidate           Exit with error if first answer is invalid.
  --quiet                   Do not echo the answer.
  --title=string            Title to send to terminal notifier.
  --type=ami                An Amazon Machine Image ami-aaaaaaaa.
         date               A date (requires GNU date).
         environment        Either 'testing', 'staging' or 'production'.
         existing_file      A file that should already exist.
         instance-id        An AWS instance-id like i-aaaaaaaa.
         integer            A number.
         list               A comma delimited list.
         multiword          A string of words.
         singleword         A single word.
         yes_no             Either 'yes' or 'no'. (default)
  --verbose                 Echo the answer.

EOF
  exit 1
}

function __notifier() {
  if [[ "${NOTIFY}" == "no" ]]; then return 0; fi
  if ! which terminal-notifier &> /dev/null; then return 0; fi

  terminal-notifier \
    -message "${QUESTION}?" \
    -title "${TITLE}" \
    > /dev/null
}

function __set_type_settings() {
  # set the defaults
  [[ -z ${COLOUR} ]]      && COLOUR="yes"
  [[ -z ${ERROR_MSG} ]]   && ERROR_MSG="Invalid Response!"
  [[ -z ${NOTIFY} ]]      && NOTIFY="yes"
  [[ -z ${REVALIDATE} ]]  && REVALIDATE="yes"
  [[ -z ${TITLE} ]]       && TITLE="question_script"
  [[ -z ${TYPE} ]]        && TYPE="yes_no"

  case ${TYPE} in
    "existing-file")
      ACCEPTED_INPUTS=""
      ERROR_MSG="File does not exist!"
      FORMAT_HINT="file"
      DEFAULT_VERBOSE="yes"
    ;;
    "date")
      ACCEPTED_INPUTS=""
      DATE_ACCURACY="seconds"
      DATE_CMD=$(which gdate || which date)
      DEFAULT_VERBOSE="yes"
      ERROR_MSG="Not a date!"
      FORMAT_HINT="date"
    ;;
    "regex")
      ACCEPTED_INPUTS=${ACCEPTED_INPUTS}
      FORMAT_HINT="'${ACCEPTED_INPUTS}'"
      DEFAULT_VERBOSE="yes"
    ;;
    "ami")
      ACCEPTED_INPUTS="^ami-[a-f0-9]{8}$"
      FORMAT_HINT="ami-xxxxxxxx"
      DEFAULT_VERBOSE="yes"
    ;;
    "list")
      ACCEPTED_INPUTS=".*"
      FORMAT_HINT="comma delimited list"
      DEFAULT_VERBOSE="yes"
    ;;
    "environment")
      ACCEPTED_INPUTS="^(testing|staging|production)$"
      ERROR_MSG="Not a valid environment!"
      FORMAT_HINT="testing|staging|production"
      DEFAULT_VERBOSE="yes"
    ;;
    "instance-id")
      ACCEPTED_INPUTS="^i-[a-f0-9]{8}$"
      ERROR_MSG="Not a valid instance-id!"
      FORMAT_HINT="i-xxxxxxxx"
      DEFAULT_VERBOSE="yes"
    ;;
    "integer")
      ACCEPTED_INPUTS="^[0-9]+$"
      FORMAT_HINT="integer"
      DEFAULT_VERBOSE="yes"
    ;;
    "multiword")
      ACCEPTED_INPUTS="^.*[^\ ].*$"
      FORMAT_HINT="string"
      DEFAULT_VERBOSE="yes"
    ;;
    "singleword")
      ACCEPTED_INPUTS="^[^\ ]+$"
      FORMAT_HINT="single word"
      DEFAULT_VERBOSE="yes"
    ;;
    "yes_no")
      ACCEPTED_INPUTS="^(yes|no)$"
      FORMAT_HINT="yes|no"
      DEFAULT_VERBOSE="no"
    ;;
    *)
      usage
    ;;
  esac
  [[ -z ${VERBOSE} ]]     && VERBOSE=${DEFAULT_VERBOSE}
}

function __answer_valid() {
  if [[ -z "${ANSWER}" ]]; then return 1; fi
  if [[ "${ATTEMPT}" -gt 30 ]]; then
    echo "you seem to be having a hard time. ;)"
    exit 1
  fi

  if [[ ${TYPE} == "date" ]]; then
    if ! [[ $(${DATE_CMD} --version 2> /dev/null) =~ GNU\ coreutils ]]; then
      echo "Error: You are not running GNU date."
      exit 1
    fi
  fi

  if [[ -z "${ATTEMPT}" ]]; then
    ATTEMPT=1
  else
    ATTEMPT=$(( ${ATTEMPT} + 1 ))
  fi

  case "${TYPE}" in
    "date")           ANSWER=$(${DATE_CMD} --date="${ANSWER}" --rfc-3339="${DATE_ACCURACY}" 2> /dev/null) ;;
    "existing-file")  [[ -f "${ANSWER}" ]]                                  ;;
    *)                echo "${ANSWER}" | egrep "${ACCEPTED_INPUTS}" &> /dev/null ;;
  esac
  return $?
}

function __strip() {
  echo $1 | psed 's/^\ *//g' | psed 's/\ *$//g'
}

function print_question() {
  cecho_path="$(which cecho)"
  if [[ -z "${cecho_path}" ]]; then COLOUR="no"; fi

  case "${COLOUR}" in
    "yes")  ${cecho_path} -n --magenta "${QUESTION}" > /dev/stderr ;;
    *)      echo -n "${QUESTION}" > /dev/stderr      ;;
  esac
}

function print_answer() {
  # convert list into quoted strings.
  if [[ ${TYPE} == "list" ]]; then
    ANSWER=$(echo ${ANSWER} | sed 's/"/\\"/g')
    ANSWER=$(echo ${ANSWER} | sed 's/^/"/' | sed 's/\ *,\ */" "/g' | sed 's/$/"/')
  fi

  if [[ "${VERBOSE}" == "yes" ]]; then
    echo "${ANSWER}"
    exit 0
  else
    [[ ${ANSWER} != "no" ]]
    exit $?
  fi
}

### USER SETTINGS #############################################################
for arg in "$@"; do
  k=$(echo ${arg} | cut -d= -f1)
  v=$(echo ${arg} | cut -d= -f2-)

  case "${k}" in
    "--accepted-inputs")          ACCEPTED_INPUTS="$v"; TYPE="regex"        ;;
    "--help")                     usage                                     ;;
    "--no-colour"|"--no-color")   COLOUR="no"                               ;;
    "--no-notify")                NOTIFY="no"                               ;;
    "--no-revalidate")            REVALIDATE="no"                           ;;
    "--quiet")                    VERBOSE="no"                              ;;
    "--title")                    TITLE="$v"                                ;;
    "--type")                     TYPE="$v"                                 ;;
    "--verbose")                  VERBOSE="yes"                             ;;
    *)                            QUESTION=$(__strip "${QUESTION} ${arg}")  ;;
  esac
done

__set_type_settings

# TODO: refactor
QUESTION="${QUESTION} (${FORMAT_HINT})? "

[[ -z ${QUESTION} ]]        && usage
__notifier

if [[ "${REVALIDATE}" == "yes" ]]; then
  while ! __answer_valid "${ANSWER}"; do
    print_question > /dev/stderr
    read ANSWER
  done
else
  print_question > /dev/stderr
  read ANSWER

  # TODO: refactor
  if ! __answer_valid; then
    echo ${ERROR_MSG}
    exit 1
  fi
fi

print_answer

exit 0
